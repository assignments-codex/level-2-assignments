You’ll build a **professional website of your choice** and present it on Friday in an interview‑style session. You are **not graded on visual theme**. Pick a theme quickly and focus on **technical quality**, because time is limited. You will also complete a short **live‑coding** demonstration on a Level‑2 skill.

---

## What you are building

- A small web app/site that solves a clear problem for a user.
- A simple, professional presentation of your idea (branding/theme is optional; not graded).
- Technical focus over aesthetics.

---

## Minimum requirements (build checklist)

Make sure your project includes **all** of the following before you present:

- **Live link** (e.g., GitHub Pages) and a **public repo**.
- **Responsive layout** using utilities or components (e.g., a styling framework).
- At least **one API request** with basic **error handling** (friendly message on failure).
- At least **one data transformation** (e.g., map/filter/reduce) or a small **summary**.
- At least **one class/module pattern** used meaningfully (e.g., service or session class).
- **Safe DOM updates** (`textContent` or equivalent).
- **README** with setup notes, links, and a short architecture description.

> Optional: a **chat interface** using an AI provider (e.g., Google Gemini, Cloudflare Workers AI) with a secure key approach. Not required to pass, but welcome if it supports your idea.

---

## Friday presentation (10–12 minutes total)

1. **Live site demo** (≈2 min): problem -> solution -> core flow.
2. **Code walkthrough** (≈3–4 min): show specific files you’re proud of; explain decisions and trade‑offs.
3. **Q&A on code** (≈2–3 min): be ready to explain any part of your repo.
4. **Live coding** (≈3–4 min, no AI): instructor will choose a small task related to Level‑2 skills.

---

## Live‑coding demonstration (what to expect)

You will be asked to perform **one** small task chosen by your instructor, such as:

- Writing a **pure function** given inputs/outputs.
- Performing **array processing** with `map`, `filter`, or `reduce`.
- Implementing a **string utility** (normalize, tokenize, or format).
- Creating a **simple object or class** with one or two methods and showing usage.
- Sketching an **async fetch** skeleton with error guards (no real secrets).
- Rendering a small **DOM update** safely based on data.

Keep code short, speak your thinking, and do a quick console check if time allows.

---

## What to submit

- **Live URL** and **Repo URL** (in your LMS submission).
- README that includes:
  - One‑paragraph product brief (who/what/why).
  - Links to live site and repo.
  - Short architecture overview (files, classes/services, data flow).
  - Any notes on API keys or AI usage (no secrets committed).

---

## Student rubric (100 points)

Use this to self‑check before you present. Scoring focuses on **skills**, not theme.

- **1) Live coding - 50 pts**

  - Correct, runnable solution to the prompt. (0–10)
  - Handles a basic edge case or input validation. (0–10)
  - Clear, idiomatic JS (names, small functions). (0–10)
  - Think‑aloud reasoning while coding. (0–10)
  - Quick self‑check (console/test) and revise if needed. (0–10)

- **2) Explaining code - 30 pts**

  - Design intent & trade‑offs (why these components/classes/services). (0–10)
  - Data flow & state/error handling (async patterns, fetch guards). (0–10)
  - Constraints & alternatives (security/keys, rate limits, performance). (0–10)

- **3) Presentation & professionalism - 20 pts**
  - Live link first; clear story; links ready. (0–5)
  - Concise, accurate communication; appropriate technical vocabulary. (0–5)
  - Time management; stays within 10–12 minutes. (0–5)
  - Q&A handled precisely; acknowledges unknowns and reasons about fixes. (0–5)

**Total:** \_\_/100

---

## Tips for success

- Keep scope **tight**. One reliable flow is better than five half‑working features.
- Practice your **demo script** and one short **live‑coding** warm‑up.
- Use **ACP**: small, meaningful commits as you build.
- If you use AI in your app, follow a **secure key approach** and write it down in your README.

Good luck - build something you’re proud to explain!
